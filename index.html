	<!DOCTYPE HTML>

<html>
	<head>
		<title>Portfolio Artur Skrzeta</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
	</head>
	<body class="is-preload">

		<!-- Header -->
			<section id="header">
				<header>
					<span class="image avatar"><a href="https://arturskrzeta.github.io/"><img src="images/avatar.png" alt="" style="margin-bottom:0px"/></a></span>
					<h1 id="logo"><a href="https://arturskrzeta.github.io/">Artur Skrzeta</a></h1>
					<p>Data Analyst<br />
					+4 years experience</p>
				</header>
				<nav id="nav">
					<ul>
						<li><a href="#one" class="active">Intro</a></li>
						<li><a href="#two">Features</a></li>
						<li><a href="#three">Demo</a></li>
						<li><a href="#four">Setup</a></li>
						<li><a href="#five">Source Code</a></li>
					</ul>
				</nav>
				<footer>
					<ul class="icons">
						<li><a href="https://www.linkedin.com/in/artur-skrz%C4%99ta-010b23187/" class="icon brands fa-linkedin"><span class="label">LinkedIn</span></a></li>
						<li><a href="https://www.instagram.com/arturskrrr/" class="icon brands fa-instagram"><span class="label">Instagram</span></a></li>
						<li><a href="https://github.com/ArturSkrzeta" class="icon brands fa-github"><span class="label">Github</span></a></li>
						<li><a href="mailto: arturskrzeta@gmail.com" class="icon solid fa-envelope"><span class="label">Email</span></a></li
					</ul>
				</footer>
			</section>

		<!-- Wrapper -->
			<div id="wrapper">

				<!-- Main -->
					<div id="main">

						<!-- One -->
							<section id="one">
								<div class="container">
									<header class="major">
										<h2>Application in a Container</h2>
										<h3>Intro</h3>

										<h5>When to use Docker:</h5>
										<ul>
											<li>We want to make an application portable.</li>
											<li>Sharing app with someone else so that someone can run it on its local machine.</li>
											<li>App deployment on cloud's server.</li>
										</ul>

										<h5>Deckerizing an application:</h5>
										<ol>
											<li>Preparing DockerFile that contains set of instructions.</li>
											<li>Running build command to buld Docker image due to instructions.</li>
											<li>Docker reaches the cache memeory to see if some of the instructions were executed earlier so that it doesn't execute it again.</li>
											<li>When building first time, we import basic Docker image from the Docker registry.</li>
											<li>Then on top of that, we append following elements of app's environment due to Dockerfile's instructions.</li>
											<li>When Docker image we can run as many Docker containers as we want using built image.</li>
										</ol>

										<img src="images/dockerflow.JPG">

										<h5>Docker container:</h5>
										<ul>
											<li>Unlike Virtual Machines, Docker containers are not meant to host operating systems.</li>
											<li>Containers are meant to run a specific task or process like hosting instance of web server, application or database, computation or analysis.</li>
											<li>Once the task is complete, the container terminates. Container lives as long as the process inside it is alive.</li>
										</ul>

										<h5>Virtual Machines vs Docker Containers:</h5>
										<img src="images/vm_vs_docker.jpg	" width="700"><span style="font-size:12px;">source: geekflare</span><br><br>
										<table>
											<thead>
												<tr>
													<th>Virtual Machine</th>
													<th>Docker Containers</th>
												</tr>
											</thead>
											<tbody>
												<tr>
													<td>VMs don't share resources with host operating system.</td>
													<td>Containers share resources with host operating system.</td>
												</tr>
												<tr>
													<td>With Guest Os you start with full-fledged operting sytem and then you can strip out things you don't need for an app.</td>
													<td>By sharing resources you start wit the basics and you add up what you need for an app.</td>
												</tr>
											</tbody>
										</table>

										<h5>Docker Architecture:</h5>
										<ol>
											<li>Docker Daemon on a server - manages docker objects: images, containers, network. Runs on OS. Its build from following components:
												<br>
												- volumes for pesisting data in a docker container.<br>
												- network interface for docker containers,<br>
												- container runtime for managing container lifecycle - it runs and stops a contaier.<br>
												- builder that builds images from a Dockerfile.
											</li>
											<li>REST API available by Docker Daemon as interface to interact to Daemon - passing docker commands.</li>
											<li>Client Docker CLI (Command Line Interface) for communication with docker daemon.</li>
										</ol>
										<img src="images/docker_architecture.jpg" width="700"><span style="font-size:12px;">source: geekflare</span><br><br>
										<ul>
											<li>docker build command -> docker daemon looks for docker file to create an image.</li>
											<li>docker pull command -> docker daemon pulls an image from registry docker hub into docker host.</li>
											<li>docker run command -> docker daemon runs an image into docker container within docker host.</li>
										</ul>

										<h3>Multi-container Apps</h3>
										<h5>Docker Compose:</h5>
										<ul>
											<li>It is very helpful when we use different technologies and each of them we want to contenerize in its own isolated environment.</li>
											<li>We can use Docke Compose for connecting and orchestrating them in order to define and run multi-container Docker applications.</li>
											<li>Each container needs to have its own Dockerfile that defines its running environment.</li>
											<li>Each container should be providing a snigle service: user login service, user registraion service, db and so on.</li>
											<li>All the necessary configuration of how much conatiers (services) make up the application is placed in the compose file format: <code>docker-compose.yml</code></li>
											<li>There are 3 steps to make it run:
												<br>
												1. Writing a <code>Dockerfile</code> with proper app's environment settings - one dockerfile per one service that will be contenerzied.<br>
												2. Defining all the necessary sevices that make up the applicaion in the file:<br> <code>docker-compose.yml</code> in a parent directory.<br>
												3. Running it with command: <code>docker-compose up</code>.
											</li>
											<li>That way we can define services and link them with each other.</li>
											<li>Docker Compose is included in Docker Desktop for Windows.</li>
											<li>Docker Compose can be installed also with pip as well: <code>pip install docker-compose</code>.</li>
											<li>When containerizing, we can specify which files can be ignored by putting the into <code>.dockerignore</code>:
												<br>
												- over there we just need to specify directory of it:<br>
												<code>venv/</code><br>
												<code>__pycache__/</code>
											</li>
										</ul>

										<h5>Kubernetes aka k8s:</h5>
										<ul>
											<li>Kubernetes supports different container runtimes.</li>
											<li>Open-source platform for clustering, running, scaling and managing containerized applicatons.</li>
											<li>It groups conatiners into logical services that builds up final application.</li>
											<li>Key elements:
												<br>
												- <b>Pod</b> - represents a runnable unit of work. Can store one or more containers. It's connected via network to the kubernetes ecosystem.<br>
												- <b>Replication controller</b> - managing number of pods. Contains a pod template for creating any number of pods. That allows to manage pods life cycle including scaling up or down, rolling deployments and monitoring.<br>
												- <b>Service</b> - tells rest of the kubernetes ecosystem including other pods and replication controllers what service your application provides. Storing ip address and ports of your service.<br>
												- <b>Volume</b> - location where containers access and store data.<br>
												- <b>Labels</b> - nametags to identify things and we can query based on these labels. Can be used to indicate stability, roles and other important attributes.<br>
												- <b>Namespace</b> - grouping mechanism that segments pods, replication controllers, volumes and services. It provides a degree of isolation.
											</li>
											<li>As to Kubernetes architecutre it has its own CLI, network interface, and volume and it doesn't build images inside of clusters so only thing it needs when clustering docker containers is docker container runtime.</li>
										</ul>

										<h5>Kubernetes Load Balancer:</h5>
										<ul>
											<li>Kubernetes is able to create multiple instances (pods) of the application such that a traffic can be distributed evenly preventing app from getting crashed.</li>
											<li>User accessing the application will not directly hit its URL but they will call load balancer that distributes traffic over number of app's intances.</li>
											<li>That way Kubernetes serves the application scalably - when one app instance crashes it creates another ensuring reliable and scalable app deployment.</li>
										</ul>

										<h5>Deployment on Kubernetes</h5>
										<ul>
											<li>Checking if kubernetes cluster installed
												<br>
												<code>kubectl version --client</code>
											</li>
											<li>It requires setting config file up: <code>deployment.yaml</code></li>
											<li>Deploying applications with Kubernetes can be easily managed using the cli tool called kubectl:
												<br>
												<code>kubectl apply -f deployment.yaml</code>.
											</li>
											<li>Displaying dashboard:
												<br>
												<code>minikube dashboard</code>.
											</li>
										</ul>

									</header>
								</div>
							</section>

						<!-- Two -->
							<section id="two">
								<div class="container">
									<h3>Features</h3>
									<p>App includes following features:</p>
									<ul class="feature-icons">
										<li class="icon solid fa-check">Docker</li>
										<li class="icon solid fa-check">Python</li>
									</ul>
								</div>
							</section>

						<!-- Three -->
							<section id="three">
								<div class="container">
									<h3>Demo</h3>

									<h5>Dockerfile:</h5>
									<ul>
									  <li>A text document that contains all the commands a user could call on command prompt to assemble an image.</li>
										<li>Simply put, it lists steps to create Docker Image i.e.:
											<br>
											- pulling base image from Docker Registry,<br>
											- stating working directory in a container,<br>
											- copying all dependent files into a container working directory,<br>
											- calling commands in order to install dependencies,<br>
											- copying source code into a container working directory,<br>
											- calling commands in order to run an application.
										</li>
										<li>Every Dockerfile's step I list above is executed by Docekr builder in the given order: from top to bottom.</li>
										<li>Docekr builder goes through a Dockerfile and for each instruction or command in there it generates an image layer and stacks it.
											The more insctructions or commands a Dockerfile includes, the more layers as stachk upon each other.</li>
										<li>Here comes Docker image definition which is a stack of different layers built due to what we got in Dockerfile.</li>
									</ul>

									<h5>Docker image:</h5>
									<ul>
										<li>For every new Docker image that builder creates, there are check being made against cached images that were built before. In order to explain this mechanizm lets assume a scenario:
											<br>
											- the Docker file that had been used for building images so far was changed by modifing a one of instructions,<br>
											- images that were built from that Dockerfile before were cached,<br>
											- Docker builder goes through instrucion of Dockerfile and detects modified instruction,<br>
											- Docker builder recognizes what layer in cached image modified instruction affects,<br>
											- Docker builder rebuilts that image layer and all the onec coming after.
										</li>
										<li>Caching mechanizm works the best when we place the insctructions that may undergo some modifications after the ones that will be stable and unchanged along the time.</li>
									</ul>

									<h5>Dockerfile example:</h5>
									<ul>
										<li>Here is the example of Dockerfile:
											<br>
											# set base image downloaded from Docker repository<br>
											<code>FROM python:3.7</code><br>
											# set the working directory in the container<br>
											<code>WORKDIR /code</code><br>
											# copy the file form dockerfile directory to the current working directory of the container<br>
											<code>COPY requirements.txt .</code><br>
											# running command inside docker container while image running: install dependencies<br>
											<code>RUN pip install -r requirements.txt</code><br>
											# copy the content of the local src directory to the working directory<br>
											<code>COPY src/ .</code><br>
											# app will run on port 5000 inside docker contaier<br>
											<code>Expose: 5000</code><br>
											# making container in a running stage<br>
											<code>CMD [ "python", "./main.py" ]</code>
										</li>
										<li>Due to the fact, the application’s dependencies change less frequently than the Python code, the insctruction of installing dependencies precedes the instruction of exporting app's source code to the container.</li>
										<li>That way, we have the source code layer upon the dependencies layer and any changes to the code won't affect the dependencies layer.</li>
									</ul>

									<h5>Terminal:</h5>
									<ul>
										<li>Building image and running a container:
											<br>
											- changing directory to the one of Dockerfile's:<br>
											<code>cd ./docker_test</code><br>
											- building image giving an image_name:tag and current directory (dot):<br>
											<code>docker build -t image_name:latest .</code><br>
											- listing all images:<br>
											<code>docker images</code><br>
											- running container which runs application on port 5000:<br>
											<code>docker run -it -d -p 5000:5000 --name container_name image_name</code><br>
											- check all the docker containers:<br>
											<code>docker ps</code><br>
											- mapping local directory to container container in order to get outputs from container to local directory:
											<code>docker run -v C:\...\docker_test:/code</code><br>
											- mapping local dir: <code>C:\...\docker_test</code> to container dir: <code>/code</code>
										</li>
									</ul>

									<h5>Other Docker commands:</h5>
									<ul>
										<li>Here are some useful docker cmd commands:
											<br>
											- checking docker after installation:<br>
											<code>docker -v</code><br>
											<code>docker run hello-world</code><br>
											- listing all containers:<br>
											<code>docker container ls -a</code><br>
											<code>docker ps</code><br>
											- removing container with name:<br>
											<code>docker container rm container_name</code><br>
											- listing all images:<br>
											<code>docker images</code><br>
											- removing image with name:<br>
											<code>docker image rm xxx</code><br>
											- pulling image from docker hub, however it doesn't create a container:<br>
											<code>docker pull python</code><br>
											<code>docker images python</code><br>
											<code>docker container stop image_name</code><br>
											- entering container:<br>
											<code>docker container exec -it image_name bash</code>
										</li>
										<li>Getting all dependencies for a Python app:
											<br>
											- activating Virtual Environment:<br>
											<code>env/scripts>activate</code><br>
											- listing all lisnalled dependecies:<br>
											<code>pip list</code><br>
											-pasting all dependencies with their version into a txt file:<br>
											<code>pip freeze > requirements.txt</code>
										</li>
									</ul>

									<h5>Pulling from Docker Hub:</h5>
									<ul>
										<li>Cmd:
											<br>
											<code>docker pull mongo</code><br>
											<code>mkdir mongodb_test</code><br>
											<code>cd mongodb_test</code><br>
											when running an image, we map volume with -v and ports -p:<br>
											<code>docker run -it -v mongodata:/data/db -p 27017:27017 --name mongodb -d mongo</code>
											entering container's bash:<br>
											<code>docker exec -it my_mongo bash</code><br>
											entering mongo shell:<br>
											<code>mongo</code><br>
											<code>show dbs</code><br>
											<code>use test</code><br>
											<code>db.user.insert({"name":"Artur"})</code><br>
											<code>db.user.find()</code><br>
											exiting a mongo's shell:<br>
											<code>exit</code><br>
											exiting the contianer:<br>
											<code>exit</code>
										</li>
									</ul>

									<h5>Docker-compose.yml example:</h5>
									<ul>
										<li>Code:
											<br>
											# declaring verison of docker compose file format<br>
											<code>version: "3.7"</code><br>
											<code>services:</code><br>&nbsp&nbsp&nbsp
												<code>flask:</code><br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
												# building the flask service (container) using the Dockerfile in the flask directory<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
												<code>build: ./flask</code><br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
												# give the flask contianer a name<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
												<code>container_name: flask</code><br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
												# instructing Docker to alwyas restart the service<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
												<code>reastart: always</code><br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
												# setting environment variables we want to pass into the container<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
												<code>environment:</code><br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
													<code>- APP_NAME=MyFlaskApp</code><br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
													<code>- DB_USERNAME=user_name</code><br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
												# listing ports for internal services on the same network<br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
												<code>expose:</code><br>&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp&nbsp
													<code>- 8080</code>
										</li>
										<li>Cmd:
											<br>
											- building all contaiers:<br>
											<code>docker-compose build</code><br>
											- running all containers:<br>
											<code>docker-compose up</code><br>
											- when changes to a code we need to rebuild contaienrs:<br>
											<code>docker-compose up --build</code><br>
											- stopping containers:<br>
											<code>docker-compose down</code>
										</li>
									</ul>


								</div>
							</section>


						<!-- Four -->
							<section id="four">
								<div class="container">
									<h3>Setup</h3>
									<p>Following installation required:</p>
									<ul>
										<li>Docker installation from https://www.docker.com/</li>
										<li>Enable Kubernetes in Docker Desktop settings.</li>
										<li>Minikube</li>
									</ul>
								</div>
							</section>

							<section id="five">
								<div class="container">
									<h3>Source Code</h3>
									<p>You can view the source code: <a href="https://github.com/ArturSkrzeta/Application-in-a-Container/tree/main/files">HERE</a></p>
									<p>&nbsp</p>
								</div>
							</section>

					</div>

				<!-- Footer -->
					<section id="footer">
						<div class="container">
							<a href="https://arturskrzeta.github.io/" style="padding-bottom:10px;">Back to Portfolio</a>
						</div>
					</section>

			</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>
